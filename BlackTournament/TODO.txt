server game logic
# - static collisions
# - dynamic collision (dyn to dyn)

client game logic
X - static collisions (dyn to stat where dyn is owned by local)


# key(input) to enum(Action) mapping


idee: ein quasi rollensystem mittels actions realisieren - ähnlich continuos animations - gibts die nicht schon?


idee: controller durch rollen ersetzen die am jeweiligen state hängen



# fix missing key-up event on focus loss?!


#add id-d shots & 
#pickups to serialization chain

UC create game data from parsed map data?

create basic UI elements

add MD5 comparison against map tampering / versioning


Network data brainstorm MK2 >> delay mechanisms

Operations:
-Object Move
-Weapon Change
-Weapon Fire
-Collision

Type
id
x,y,r
active
health
shield

ex:
player
15
0;15;74
true
100
0

pickup
7
false













#Collision Notes:

        Primitives: Point, Line, Circle, AARectangle, Poligon
            
        Point - Point => ==
        Point - Line => *1+lenght
        Point - Circle => dist >= rad
        Point - AAR => classic minmax
        Point - Poly => *n

        Line - Line => *2
        Line - Circle => special *2
        Line - AAR => *3 (ggf berücksichtigen: sonderfall: AAR projectionsaxen = coordinatenachsen)
        Line - Poly -> *1+n

        Circle - Circle => dist & rad compare
        Circle - AAR => minmax + radial dist (http://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection#402010)
        Circle - Poly => special * 1+n

        AAR -> AAR -> classic minmax
        AAR -> Poly -> *2+n

        Poly - Poly -> *n+n


        Collision Prefilter based on type(ie: wall cant collide with wall)
        sort collideables into typegroups for that

        check typegroups against eachother

        either use step ahead collision to prevent collisions
        or
        calculate all intersection distances based on * and move either one along the projection axis with the lowest distance


blending:
- static sprite internal rendermasks can be achieved with a pixel shader
- dynamic blending can only be achieved with an aditional render to texture step and a custom blendmode using dstalpha