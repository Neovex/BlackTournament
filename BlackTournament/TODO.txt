#finalize projectile (weapon) lighting
complete map powerplant
-# collision, pickup, spawns
-# lights
-- check radiation zone damage (postponed until HUD ready)
#fix net message crash when switching maps (somethings not properly disposed!)
#fix UI focusloss mouse VS gamepad
#fix UI broken keyboard/UI input
#find solution for comboboxes and other UI dialogs -> screen filling overlay with auto close - this is the space for all dialog-like interfaces
#replace main menue->host->map textbox with dynamically filled combo-box
rename states to scenes
HUD!
-- create template
-# create weapon icons
fix connecting to invalid server causing crash instead of proper message
update playergraphics (animation?)
death sounds (and effects)
pickup sounds
(complete map temple)
(env sounds?)
(consider UI Markup)
(consider Particle Markup)



server game logic
# - static collisions
# - dynamic collision (dyn to dyn)

client game logic
X - static collisions (dyn to stat where dyn is owned by local)


# key(input) to enum(Action) mapping


idee: ein quasi rollensystem mittels actions realisieren - ähnlich continuos animations - gibts die nicht schon?
X idee: controller durch rollen ersetzen die am jeweiligen state hängen


# create emitter configurations for VFX

# fix collision bug: no collision / intersection between rectangle and 0 degree ray (->)

#add id-d shots & 
#pickups to serialization chain

UC create game data from parsed map data?

# create basic UI elements

add MD5 comparison against map tampering / versioning

Notes on Lighting:
    Pointlight
        Position
        Color
        SIze
        Flicker



#Collision Notes:

        Primitives: Point, Line, Circle, AARectangle, Poligon
            
        Point - Point => ==
        Point - Line => *1+lenght
        Point - Circle => dist >= rad
        Point - AAR => classic minmax
        Point - Poly => *n

        Line - Line => *2
        Line - Circle => special *2
        Line - AAR => *3 (ggf berücksichtigen: sonderfall: AAR projectionsaxen = coordinatenachsen)
        Line - Poly -> *1+n

        Circle - Circle => dist & rad compare
        Circle - AAR => minmax + radial dist (http://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection#402010)
        Circle - Poly => special * 1+n

        AAR -> AAR -> classic minmax
        AAR -> Poly -> *2+n

        Poly - Poly -> *n+n


        Collision Prefilter based on type(ie: wall cant collide with wall)
        sort collideables into typegroups for that

        check typegroups against eachother

        either use step ahead collision to prevent collisions
        or
        calculate all intersection distances based on * and move either one along the projection axis with the lowest distance


blending:
- static sprite internal rendermasks can be achieved with a pixel shader
- dynamic blending can only be achieved with an aditional render to texture step and a custom blendmode using dstalpha




emitter backup - beautiful fire:
(new SmokeEmitter(_Core, smokeTex, BlendMode.Add)
            {
                ParticlesPerSpawn = 25,
                Color = new Color(255,100,20,255),
                Speed = 25,
                Alpha = 1f,
                Scale = new Vector2f(0.2f,0.2f),
                Origin = smokeTex.Size.ToVector2f() / 2,

                Loop = true,
                SpawnRate = 0.05f
            });