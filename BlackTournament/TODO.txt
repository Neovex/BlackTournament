
# implement map renderer see layername lookup in layerproperty 4 ease

# complete input abstraction layer - key to action mapping - editable (maybe check tf3 for that)

# server pure data abstraction layer - poco game data 4 serialization

# create collision backend

server game logic
- dynamic collision (dyn to dyn)

client game logic
- static collisions (dyn to stat where dyn is owned by local)


# key(input) to enum(Action) mapping


idee: ein quasi rollensystem mittels actions realisieren - ähnlich continuos animations - gibts die nicht schon?


idee: controller durch rollen ersetzen die am jeweiligen state hängen



fix missing keyup event on focus loss?!


add id-d shots & pickups to serialization chain

create game data from parsed mapdata?

network -> shots are only sent once - movement is then interpolated? - problem: wall collisions


#Network data brainstorm

Type
id
xyr
active
health
shield

ex:
player
15
0;15;74
true
100
0

pickup
7
false













#Collision Notes:

        Primitives: Point, Line, Circle, AARectangle, Poligon
            
        Point - Point => ==
        Point - Line => *1+lenght
        Point - Circle => dist >= rad
        Point - AAR => classic minmax
        Point - Poly => *n

        Line - Line => *2
        Line - Circle => special *2
        Line - AAR => *3 (ggf berücksichtigen: sonderfall: AAR projectionsaxen = coordinatenachsen)
        Line - Poly -> *1+n

        Circle - Circle => dist & rad compare
        Circle - AAR => minmax + radial dist (http://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection#402010)
        Circle - Poly => special * 1+n

        AAR -> AAR -> classic minmax
        AAR -> Poly -> *2+n

        Poly - Poly -> *n+n


        Collision Prefilter based on type(ie: wall cant collide with wall)
        sort collideables into typegroups for that

        check typegroups against eachother

        either use step ahead collision to prevent collisions
        or
        calculate all intersection distances based on * and move either one along the projection axis with the lowest distance


blending:
- static sprite internal rendermasks can be achieved with a pixel shader
- dynamic blending can only be achieved with an aditional render to texture step and a custom blendmode using dstalpha