server game logic
# - static collisions
# - dynamic collision (dyn to dyn)

client game logic
X - static collisions (dyn to stat where dyn is owned by local)


# key(input) to enum(Action) mapping


idee: ein quasi rollensystem mittels actions realisieren - ähnlich continuos animations - gibts die nicht schon?
X idee: controller durch rollen ersetzen die am jeweiligen state hängen


# create emitter configurations for VFX

# fix collision bug: no collision / intersection between rectangle and 0 degree ray (->)

#add id-d shots & 
#pickups to serialization chain

UC create game data from parsed map data?

# create basic UI elements

add MD5 comparison against map tampering / versioning

Notes on Lighting:
	Pointlight
		Position
		Color
		SIze
		Flicker



#Collision Notes:

        Primitives: Point, Line, Circle, AARectangle, Poligon
            
        Point - Point => ==
        Point - Line => *1+lenght
        Point - Circle => dist >= rad
        Point - AAR => classic minmax
        Point - Poly => *n

        Line - Line => *2
        Line - Circle => special *2
        Line - AAR => *3 (ggf berücksichtigen: sonderfall: AAR projectionsaxen = coordinatenachsen)
        Line - Poly -> *1+n

        Circle - Circle => dist & rad compare
        Circle - AAR => minmax + radial dist (http://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection#402010)
        Circle - Poly => special * 1+n

        AAR -> AAR -> classic minmax
        AAR -> Poly -> *2+n

        Poly - Poly -> *n+n


        Collision Prefilter based on type(ie: wall cant collide with wall)
        sort collideables into typegroups for that

        check typegroups against eachother

        either use step ahead collision to prevent collisions
        or
        calculate all intersection distances based on * and move either one along the projection axis with the lowest distance


blending:
- static sprite internal rendermasks can be achieved with a pixel shader
- dynamic blending can only be achieved with an aditional render to texture step and a custom blendmode using dstalpha




emitter backup - beautiful fire:
(new SmokeEmitter(_Core, smokeTex, BlendMode.Add)
            {
                ParticlesPerSpawn = 25,
                Color = new Color(255,100,20,255),
                Speed = 25,
                Alpha = 1f,
                Scale = new Vector2f(0.2f,0.2f),
                Origin = smokeTex.Size.ToVector2f() / 2,

                Loop = true,
                SpawnRate = 0.05f
            });